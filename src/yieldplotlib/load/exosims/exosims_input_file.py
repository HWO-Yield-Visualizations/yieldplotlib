"""Node for handling input json files."""

import copy
from pathlib import Path

from astropy import units as u
from EXOSIMS.Prototypes.OpticalSystem import OpticalSystem
from EXOSIMS.util.get_module import get_module_from_specs

from yieldplotlib.core.file_nodes import JSONFile
from yieldplotlib.key_map import KEY_MAP

# Define which nested keys correspond to the modes, systems, and
# instruments for parsing.
# Could also be added as a flag in the key_map
INST_KEYS = [
    "QE",
    "optics",
    "sread",
    "idark",
    "texp",
    "pixelScale",
    "Rs",
    "lenslSamp",
    "pixelNumber",
    "pixelSize",
    "FoV",
    "pixelScale",
    "CIC",
    "radDos",
    "PCeff",
    "ENF",
]

SYST_KEYS = [
    "syst_optics",
    "syst_lam",  # Named syst_lam to differentiate from the mode's lam key
    "syst_deltaLam",
    "syst_BW",
    "ohTime",
    "occulter",
    "contrast_floor",
    "IWA",
    "OWA",
    "core_platescale",
    "occ_trans",
    "core_thruput",
    "core_area",
    "core_contrast",
    "core_mean_intensity",
    "koAngles_Small",
    "koAngles_Sun",
    "koAngles_Moon",
    "koAngles_Earth",
]


MODE_KEYS = ["detectionMode", "SNR", "timeMultiplier", "lam", "deltaLam", "BW"]

# EXOSIMS keys that might be paths, probably not complete
EXOSIMS_PATHS = {
    "top_level": ["cachedir", "binaryleakfilepath", "wdsfilepath", "EZ_distribution"],
    "starlightSuppressionSystems": [
        "occ_trans",
        "core_thruput",
        "core_mean_intensity",
        "core_area",
        "core_contrast",
    ],
    "scienceInstruments": ["QE"],
}

TL_PARAMS = [
    "Teff",
    "coords_RA",
    "coords_Dec",
    "Umag",
    "Bmag",
    "Vmag",
    "Rmag",
    "Imag",
    "Jmag",
    "Hmag",
    "Kmag",
    "diameter",
    "MsTrue",  # Note: The `true` mass is probabilistic based on MsEst
]


class EXOSIMSInputFile(JSONFile):
    """Node for handling the EXOSIMS input JSON files.

    The `data` attribute holds the input JSON file as a dictionary. Additional
    information is generated by instantiating EXOSIMS objects (as possible) and
    extracting the relevant information when the `_get` method is called.
    """

    def __init__(self, file_path: Path):
        """Initialize the EXOSIMSInputFile node with the file path."""
        super().__init__(file_path)
        self.is_input = True
        self.used_modes = []
        self.used_insts = []
        self.used_systs = []
        self._initialize_modes()
        self.process_input()
        self.create_exosims_objects()

    def _initialize_modes(self):
        """Initialize the used modes, instruments and systems."""
        self.used_modes = self.data["observingModes"]
        self.used_insts = [m["instName"] for m in self.used_modes]
        self.used_systs = [m["systName"] for m in self.used_modes]
        # Get the default detection mode and spectroscopy mode
        self.det_mode_ind = None
        self.spec_mode_ind = None
        for ind, mode in enumerate(self.used_modes):
            if mode.get("detectionMode"):
                # There is only one detection mode, so we can just use the index
                # when we hit it in the loop
                self.det_mode_ind = ind
                self.det_inst_ind = [
                    inst["name"] for inst in self.data["scienceInstruments"]
                ].index(mode["instName"])
                self.det_syst_ind = [
                    syst["name"] for syst in self.data["starlightSuppressionSystems"]
                ].index(mode["systName"])
            if "spectro" in mode["instName"] and self.spec_mode_ind is None:
                # Get the first spectroscopy mode, EXOSIMS does not define a single
                # "default" spectroscopy mode so there isn't a great way to choose
                # between them
                self.spec_mode_ind = ind
                self.spec_inst_ind = [
                    inst["name"] for inst in self.data["scienceInstruments"]
                ].index(mode["instName"])
                self.spec_syst_ind = [
                    syst["name"] for syst in self.data["starlightSuppressionSystems"]
                ].index(mode["systName"])

    def process_input(self):
        """Process the input JSON file.

        Searches through the input file and attempts to load all hardcoded paths,
        deleting any that do not exist locally to avoid errors when instantiating
        the TargetList object.
        """
        self.exosims_specs = copy.deepcopy(self.data)
        self.all_local_paths = True
        # Load or delete all hardcoded paths in the file
        # Handle top-level paths
        for key in EXOSIMS_PATHS["top_level"]:
            if key in self.exosims_specs:
                if isinstance(self.exosims_specs[key], str):
                    _file_exists = Path(self.exosims_specs[key]).exists()
                    if not _file_exists:
                        # Delete the key from the exosims_specs dictionary
                        del self.exosims_specs[key]
                        self.all_local_paths = False

        # Handle starlight suppression systems
        sss = self.data["starlightSuppressionSystems"]
        unique_systems = list(set(self.used_systs))
        for system in unique_systems:
            syst_ind = [syst["name"] for syst in sss].index(system)
            syst = sss[syst_ind]
            for key in EXOSIMS_PATHS["starlightSuppressionSystems"]:
                if key in syst:
                    if isinstance(syst[key], str):
                        _file_exists = Path(syst[key]).exists()
                        if _file_exists:
                            _data, _hdr = OpticalSystem.get_param_data(None, syst[key])
                            syst[key] = _data
                        else:
                            # Delete the key from the exosims_specs dictionary
                            del self.exosims_specs["starlightSuppressionSystems"][
                                syst_ind
                            ][key]
                            self.all_local_paths = False

        # Handle science instruments
        for instrument in self.used_insts:
            inst_ind = [inst["name"] for inst in self.data["scienceInstruments"]].index(
                instrument
            )
            inst = self.data["scienceInstruments"][inst_ind]
            for key in EXOSIMS_PATHS["scienceInstruments"]:
                if key in inst:
                    if isinstance(inst[key], str):
                        _file_exists = Path(inst[key]).exists()
                        if _file_exists:
                            _data, _ = OpticalSystem.get_param_data(None, inst[key])
                            inst[key] = _data
                        else:
                            # Delete the key from the exosims_specs dictionary
                            del self.exosims_specs["scienceInstruments"][inst_ind][key]
                            self.all_local_paths = False

    def get_unit(self, key):
        """Get the associated unit for a given key.

        This method handles both yieldplotlib keys and EXOSIMS keys:
        1. First tries a direct lookup in KEY_MAP (assuming key is a yieldplotlib key)
        2. If not found, tries to find the corresponding yieldplotlib key by looking up
           the EXOSIMS key in KEY_MAP

        Args:
            key (str):
                The key to look up the unit for (can be either a yieldplotlib key
                or an EXOSIMS key).

        Returns:
            astropy.units.Unit or None:
                The astropy Unit object if found, None otherwise.
        """
        # First try direct lookup (for yieldplotlib keys)
        if key in KEY_MAP and "EXOSIMSInputFile" in KEY_MAP[key]:
            unit = KEY_MAP[key]["EXOSIMSInputFile"].get("unit", "")
        else:
            # If not found, try to find the corresponding yieldplotlib key
            # by looking up the EXOSIMS key
            unit = self.find_unit_for_exosims_key(key)

        if unit:
            astropy_unit = u.Unit(unit)
            return astropy_unit

        return None

    def _get_mode_dict(self, inst, syst):
        """Get the dictionary for a given instrument and system.

        In EXOSIMS modes are actually identified by a hash of the full
        mode dictionary, but for this we're just looking for a used mode
        that matches the instrument and system.
        """
        mode_ind = None
        for ind, mode in enumerate(self.data["observingModes"]):
            if mode["instName"] == inst and mode["systName"] == syst:
                mode_ind = ind
                break
        if mode_ind is None:
            raise ValueError(f"No mode found with inst={inst} and syst={syst}")
        return self.data["observingModes"][mode_ind]

    def _get(self, key, inst=None, syst=None, **kwargs):
        """Custom logic for the input JSON files.

        This got a bit messy, but it handles loading from the input JSON file,
        the TargetList object, has reasonable defaults for the provided key,
        and has some management of units.

        Args:
            key (str):
                The key to look up in the data.
            inst (str, optional):
                Optional instrument name to get instrument-specific parameters.
            syst (str, optional):
                Optional system name to get system-specific parameters.
            **kwargs:
                Unused keyword arguments (usually for later `transform_data` calls).

        Returns:
            The value(s) associated with the key.
        """
        in_TL = key in TL_PARAMS
        if in_TL:
            # Simple case, just return the value from the TargetList object
            if "coords" not in key:
                val = getattr(self.TL, key)
            else:
                coords = getattr(self.TL, "coords")
                if key == "coords_RA":
                    val = coords.ra
                elif key == "coords_Dec":
                    val = coords.dec
            return val

        # Check if we're using a default mode/system/instrument
        using_default = (inst is None) and (syst is None)

        # Check if we're looking for a spectroscopy mode parameter
        is_spec = using_default and key.startswith("sc_")
        # is_det = using_default and not is_spec
        default_mode_ind = self.spec_mode_ind if is_spec else self.det_mode_ind
        default_inst_ind = self.spec_inst_ind if is_spec else self.det_inst_ind
        default_syst_ind = self.spec_syst_ind if is_spec else self.det_syst_ind

        # Strip the sc_ prefix if necessary
        key = key[3:] if is_spec else key

        # Check if the key is a valid parameter for an instrument, system, or mode
        in_INST = key in INST_KEYS
        in_SYST = key in SYST_KEYS
        in_MODE = key in MODE_KEYS
        if not in_INST and not in_SYST and not in_MODE:
            # If the key is not a valid parameter for an instrument, system, or mode
            # check if it's a top-level parameter
            val = self.data.get(key)
            if val is None:
                raise ValueError(f"Key {key} not found in EXOSIMS input file.")
            else:
                return val

        if using_default:
            # Get the default dictionary for either detection or spectroscopy
            # depending on the key
            if in_MODE:
                # Get mode first since we more often want it for lambda values
                _dict = self.data["observingModes"][default_mode_ind]
            elif in_INST:
                _dict = self.data["scienceInstruments"][default_inst_ind]
            elif in_SYST:
                _dict = self.data["starlightSuppressionSystems"][default_syst_ind]
        else:
            # Load the dictionary for the provided instrument, system, or combination
            # of the two
            if in_MODE:
                # Get mode first since we more often want it for lambda values
                _dict = self._get_mode_dict(inst, syst)
            elif in_INST:
                _insts = self.data["scienceInstruments"]
                _dict = [_inst for _inst in _insts if _inst["name"] == inst][0]
            elif in_SYST:
                _systs = self.data["starlightSuppressionSystems"]
                _dict = [_syst for _syst in _systs if _syst["name"] == syst][0]

        if _dict is None:
            raise ValueError(
                f"Key {key} not found in EXOSIMS input file or the generated "
                "TargetList object, although it should be present."
            )
        else:
            if key.startswith("syst_"):
                # Hacky way to differentiate between system/inst/mode keys
                key = key[5:]
            value = _dict.get(key)
            unit = self.get_unit(key)
            if unit:
                return value * unit
            else:
                return value

    def create_exosims_objects(self):
        """Create a TargetList object from the input JSON file.

        NOTE: To instantiate the TargetList object, we need to remove all
        paths that do not exist locally. This can result in different
        information being used to instantiate the TargetList object.
        """
        # If all paths are local, we can use the exosims_specs to instantiate a
        # SurveySimulation object and get the TargetList object from it
        # as well as other modules
        if self.all_local_paths:
            self.SS = get_module_from_specs(self.exosims_specs, "SurveySimulation")(
                **self.exosims_specs
            )
            self.TL = self.SS.TargetList
            self.OS = self.SS.OpticalSystem
        else:
            # To avoid filtering out targets, remove optional filters and set
            # minComp to 0. During the EXOSIMSDirectory object instantiation,
            # we filter TL down to the targets that are in the CSV files.
            self.exosims_specs["minComp"] = 0
            self.exosims_specs["optionalFilters"] = {}
            # Initialize the TargetList object
            self.TL = get_module_from_specs(self.exosims_specs, "TargetList")(
                **self.exosims_specs
            )

    def find_unit_for_exosims_key(self, exosims_key):
        """Find the unit for a given EXOSIMS key.

        Searches through the KEY_MAP to find a mapping where the provided EXOSIMS key
        matches the 'name' field for the specified module. If found, returns the
        corresponding unit.

        Args:
            exosims_key (str):
                The EXOSIMS key (e.g., 'pixelScale').

        Returns:
            str or None:
                The unit string if found, None otherwise.
        """
        module_name = self.__class__.__name__
        for yieldplotlib_key, module_data in KEY_MAP.items():
            # Check if this entry has data for the specified module
            if module_name in module_data:
                module_info = module_data[module_name]
                # Check if the 'name' field matches the EXOSIMS key
                if module_info.get("name") == exosims_key:
                    return module_info.get("unit", "")

        return None
